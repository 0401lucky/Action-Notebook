# 行动手帐 - 技术实现文档

> 本文档详细说明项目的技术实现细节，用于回答技术相关问题

---

## 目录

1. [技术栈详解](#一技术栈详解)
2. [架构设计](#二架构设计)
3. [核心模块实现](#三核心模块实现)
4. [数据库设计](#四数据库设计)
5. [状态管理](#五状态管理)
6. [关键算法](#六关键算法)
7. [性能优化](#七性能优化)
8. [安全机制](#八安全机制)
9. [测试策略](#九测试策略)
10. [常见技术问题解答](#十常见技术问题解答)

---

## 一、技术栈详解

### 1.1 前端框架：Vue 3

**选择理由：**
- **Composition API**：提供更灵活的代码组织方式，逻辑复用更简单
- **响应式系统**：基于 Proxy 的响应式，性能更好
- **TypeScript 支持**：官方提供完整的类型定义
- **生态成熟**：插件丰富，社区活跃

**核心特性应用：**

```typescript
// Composition API 示例：src/stores/daily.ts
export const useDailyStore = defineStore('daily', () => {
  // State - 使用 ref 定义响应式状态
  const currentRecord = ref<DailyRecord | null>(null)

  // Getters - 使用 computed 定义计算属性
  const completionRate = computed(() => {
    if (!currentRecord.value || currentRecord.value.tasks.length === 0) {
      return 0
    }
    const total = currentRecord.value.tasks.length
    const completed = currentRecord.value.tasks.filter(t => t.completed).length
    return Math.round((completed / total) * 100)
  })

  // Actions - 普通函数定义操作
  function addTask(description: string, priority: Priority = 'medium') {
    // ...
  }

  return { currentRecord, completionRate, addTask }
})
```

**优势：**
- 代码更简洁，没有 `this` 的困扰
- 类型推导更准确
- 逻辑分离更清晰

---

### 1.2 类型系统：TypeScript

**为什么使用 TypeScript：**
1. **类型安全**：编译时捕获错误，减少运行时 bug
2. **智能提示**：IDE 提供完整的代码补全
3. **重构友好**：修改类型定义后可以快速定位影响范围
4. **文档作用**：类型即文档，提高代码可读性

**类型定义示例：**

```typescript
// src/types/index.ts

/**
 * 任务接口
 */
export interface Task {
  id: string                    // 唯一标识 (UUID)
  description: string           // 任务描述
  completed: boolean            // 完成状态
  priority: Priority            // 优先级
  tags: string[]                // 标签数组
  order: number                 // 排序顺序
  createdAt: string             // 创建时间 (ISO 8601)
  completedAt: string | null    // 完成时间
}

/**
 * 优先级类型 - 使用字面量类型确保类型安全
 */
export type Priority = 'high' | 'medium' | 'low'
```

**类型安全的好处：**

```typescript
// ✅ 正确：类型检查通过
const task: Task = {
  id: '123',
  description: '完成作业',
  completed: false,
  priority: 'high',  // 只能是 'high' | 'medium' | 'low'
  // ...
}

// ❌ 错误：编译时报错
const task2: Task = {
  priority: 'urgent'  // 类型错误！
}
```

---

### 1.3 构建工具：Vite

**为什么选择 Vite：**
1. **快速启动**：基于 ESM，无需打包即可启动开发服务器
2. **热更新（HMR）**：修改代码后秒级更新，开发体验极佳
3. **按需编译**：只编译当前页面需要的模块
4. **生产优化**：基于 Rollup 打包，支持 Tree Shaking 和代码分割

**配置示例：**

```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': '/src'  // 路径别名，方便导入
    }
  },
  build: {
    target: 'es2020',  // 目标浏览器
    rollupOptions: {
      output: {
        manualChunks: {
          'vendor': ['vue', 'vue-router', 'pinia'],  // 分离第三方库
          'echarts': ['echarts']  // ECharts 单独打包
        }
      }
    }
  }
})
```

---

### 1.4 状态管理：Pinia

**为什么选择 Pinia 而不是 Vuex：**
- **更简洁的 API**：没有 mutations，直接修改 state
- **TypeScript 支持更好**：类型推导准确
- **组合式 API**：写法与 Vue 3 Composition API 一致
- **模块化**：不需要嵌套模块，扁平化结构

**Pinia Store 示例：**

```typescript
// src/stores/daily.ts
export const useDailyStore = defineStore('daily', () => {
  // State
  const currentRecord = ref<DailyRecord | null>(null)

  // Getters
  const taskCount = computed(() => currentRecord.value?.tasks.length ?? 0)

  // Actions
  function addTask(description: string): string | null {
    if (!currentRecord.value) {
      currentRecord.value = createEmptyDailyRecord()
    }
    const newTask: Task = {
      id: generateUUID(),
      description: description.trim(),
      completed: false,
      // ...
    }
    currentRecord.value.tasks.push(newTask)
    return newTask.id
  }

  return { currentRecord, taskCount, addTask }
})
```

**在组件中使用：**

```vue
<script setup lang="ts">
import { useDailyStore } from '@/stores/daily'

const dailyStore = useDailyStore()

// 直接访问 state
console.log(dailyStore.taskCount)

// 调用 action
dailyStore.addTask('新任务')
</script>
```

---

### 1.5 后端服务：Supabase

**什么是 Supabase：**
- 开源的 Firebase 替代品
- 提供 PostgreSQL 数据库、认证、存储、实时订阅等功能
- 基于 RESTful API 和 PostgreSQL 的 RLS（Row Level Security）

**为什么选择 Supabase：**
1. **快速开发**：无需搭建后端，专注于业务逻辑
2. **PostgreSQL**：成熟的关系型数据库，支持复杂查询
3. **实时功能**：支持数据库变更订阅（本项目未使用）
4. **安全性**：RLS 策略在数据库层面保护数据
5. **开源**：不用担心厂商锁定

**Supabase 客户端初始化：**

```typescript
// src/services/supabase.ts
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
const supabaseKey = import.meta.env.VITE_SUPABASE_ANON_KEY

export const supabase = createClient(supabaseUrl, supabaseKey)
export const isSupabaseConfigured = !!(supabaseUrl && supabaseKey)
```

**数据库操作示例：**

```typescript
// src/services/database.ts

// 保存记录
async saveDailyRecord(record: DailyRecord) {
  const userId = await getCurrentUserId()

  // 1. 保存主记录
  await supabase.from('daily_records').upsert({
    id: record.id,
    date: record.date,
    is_sealed: record.isSealed,
    user_id: userId
  })

  // 2. 保存任务
  await supabase.from('tasks').upsert(
    record.tasks.map(task => ({ ...task, user_id: userId }))
  )
}

// 加载记录（RLS 自动过滤）
async loadDailyRecord(date: string) {
  const { data } = await supabase
    .from('daily_records')
    .select('*')
    .eq('id', date)
    .single()

  return data
}
```

---

## 二、架构设计

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────┐
│                    用户界面层 (Views)                      │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐   │
│  │ Login    │ │Dashboard │ │  Home    │ │ Archive  │   │
│  │ View     │ │  View    │ │  View    │ │  View    │   │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘   │
└─────────────────────┬───────────────────────────────────┘
                      │ 使用组件
┌─────────────────────┴───────────────────────────────────┐
│                   组件层 (Components)                     │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐   │
│  │TaskList  │ │Journal   │ │ Pomodoro │ │ Stats    │   │
│  │          │ │Editor    │ │ Timer    │ │ Chart    │   │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘   │
└─────────────────────┬───────────────────────────────────┘
                      │ 调用 Store
┌─────────────────────┴───────────────────────────────────┐
│                 状态管理层 (Pinia Stores)                 │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐   │
│  │ auth     │ │  daily   │ │ archive  │ │ profile  │   │
│  │ Store    │ │  Store   │ │  Store   │ │  Store   │   │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘   │
└─────────────────────┬───────────────────────────────────┘
                      │ 调用 Service
┌─────────────────────┴───────────────────────────────────┐
│                    服务层 (Services)                      │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐   │
│  │ database │ │   auth   │ │ journal  │ │ storage  │   │
│  │ .ts      │ │  .ts     │ │  .ts     │ │  .ts     │   │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘   │
└─────────────────────┬───────────────────────────────────┘
                      │ 操作数据
┌─────────────────────┴───────────────────────────────────┐
│              数据持久化层 (Supabase)                      │
│  ┌─────────────────────────────────────────────────┐   │
│  │            PostgreSQL Database                   │   │
│  │  • daily_records      • user_profiles           │   │
│  │  • tasks              • focus_records           │   │
│  │  • journal_entries                              │   │
│  └─────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────┐   │
│  │              Supabase Auth                       │   │
│  └─────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────┐   │
│  │             Supabase Storage                     │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### 2.2 分层职责

| 层级 | 职责 | 文件位置 |
|-----|------|---------|
| **Views** | 页面级组件，路由对应的视图 | `src/views/` |
| **Components** | 可复用的 UI 组件，无业务逻辑 | `src/components/` |
| **Stores** | 状态管理，业务逻辑协调 | `src/stores/` |
| **Services** | 数据操作，与后端交互 | `src/services/` |
| **Database** | 数据持久化，Supabase | `supabase/` |

**数据流向：**

```
用户操作 → View → Store (action) → Service → Supabase
                     ↓
                  更新 State
                     ↓
                  触发响应式更新
                     ↓
                  View 重新渲染
```

---

### 2.3 目录结构设计原则

```
src/
├── assets/           # 静态资源（样式、图片等）
│   └── styles/       # 全局样式系统
├── components/       # 组件库（按功能模块分类）
│   ├── common/       # 通用组件（Button, Input, Card...）
│   ├── task/         # 任务相关组件
│   ├── journal/      # 日记相关组件
│   ├── pomodoro/     # 番茄钟相关组件
│   └── ...
├── composables/      # 组合式函数（可复用的逻辑）
├── router/           # 路由配置
├── services/         # 服务层（数据操作）
├── stores/           # 状态管理（Pinia stores）
├── types/            # TypeScript 类型定义
└── views/            # 页面视图
```

**设计原则：**
1. **按功能模块分类**：相关文件放在一起，降低认知负担
2. **单一职责**：每个文件只做一件事
3. **可复用性**：通用逻辑提取为 composables
4. **类型集中管理**：所有类型定义在 types 目录

---

## 三、核心模块实现

### 3.1 任务管理模块

**核心功能：**
- 添加任务
- 删除任务
- 切换完成状态
- 拖拽排序
- 完成率计算

**关键代码：src/stores/daily.ts**

```typescript
/**
 * 添加任务
 * 位置：src/stores/daily.ts:192-223
 */
function addTask(description: string, priority: Priority = 'medium', tags: string[] = []): string | null {
  // 1. 验证：拒绝空描述
  if (!description || description.trim().length === 0) {
    return null
  }

  // 2. 验证：如果已封存，拒绝修改
  if (currentRecord.value?.isSealed) {
    return null
  }

  // 3. 确保有当前记录
  if (!currentRecord.value) {
    currentRecord.value = createEmptyDailyRecord()
  }

  // 4. 创建新任务
  const newTask: Task = {
    id: generateUUID(),
    description: description.trim(),
    completed: false,
    priority,
    tags,
    order: currentRecord.value.tasks.length,
    createdAt: new Date().toISOString(),
    completedAt: null
  }

  // 5. 添加到任务列表
  currentRecord.value.tasks.push(newTask)

  // 6. 更新完成率
  updateCompletionRate()

  // 7. 标记本地数据已变更（用于自动保存）
  markModified()

  return newTask.id
}
```

**完成率计算：**

```typescript
/**
 * 完成率计算
 * 位置：src/stores/daily.ts:122-129
 */
const completionRate = computed(() => {
  if (!currentRecord.value || currentRecord.value.tasks.length === 0) {
    return 0
  }
  const total = currentRecord.value.tasks.length
  const completed = currentRecord.value.tasks.filter(t => t.completed).length
  return Math.round((completed / total) * 100)
})
```

**拖拽排序实现：**

```vue
<!-- src/components/task/TaskList.vue -->
<template>
  <draggable
    v-model="tasks"
    @end="handleDragEnd"
    item-key="id"
  >
    <template #item="{ element }">
      <TaskItem :task="element" />
    </template>
  </draggable>
</template>

<script setup lang="ts">
import draggable from 'vuedraggable'
import { useDailyStore } from '@/stores/daily'

const dailyStore = useDailyStore()
const tasks = computed({
  get: () => dailyStore.currentRecord?.tasks ?? [],
  set: (newTasks) => dailyStore.updateTaskOrder(newTasks)
})

function handleDragEnd() {
  // 拖拽结束后，updateTaskOrder 已经被调用
  // 这里可以添加保存到数据库的逻辑
}
</script>
```

---

### 3.2 日记本模块

**核心功能：**
- 多条目日记
- 富文本编辑
- 心情选择
- 按时间排序

**多条目日记数据结构：**

```typescript
// src/types/index.ts

/**
 * 日记条目接口
 */
export interface JournalEntry {
  id: string                    // 唯一标识 (UUID)
  content: string               // 日记内容（HTML 格式）
  mood: MoodType | null         // 心情（可选）
  createdAt: string             // 创建时间 (ISO 8601)
}

/**
 * 每日记录接口
 */
export interface DailyRecord {
  id: string
  date: string
  tasks: Task[]
  journal: string               // 旧字段，保留兼容
  mood: MoodType | null         // 旧字段，保留兼容
  journalEntries: JournalEntry[] // 新字段：日记条目数组
  isSealed: boolean
  completionRate: number
  createdAt: string
  sealedAt: string | null
}
```

**数据迁移逻辑：**

```typescript
/**
 * 数据迁移：将旧的单一 journal 字段迁移到 journalEntries
 * 位置：src/stores/daily.ts:69-91
 */
function migrateJournalData(record: DailyRecord): DailyRecord {
  // 确保 journalEntries 字段存在
  if (!record.journalEntries) {
    record.journalEntries = []
  }

  // 如果有旧的 journal 内容且 journalEntries 为空，则迁移
  if (record.journal && record.journal.trim().length > 0 && record.journalEntries.length === 0) {
    record.journalEntries = [{
      id: generateUUID(),
      content: record.journal,
      mood: record.mood,
      createdAt: record.createdAt
    }]
  }

  return record
}
```

**添加日记条目：**

```typescript
/**
 * 添加日记条目
 * 位置：src/stores/daily.ts:347-381
 */
function addJournalEntry(content: string, mood: MoodType | null = null): string | null {
  // 1. 验证内容非空白
  if (!validateEntryContent(content)) {
    return null
  }

  // 2. 验证：如果已封存，拒绝修改
  if (currentRecord.value?.isSealed) {
    return null
  }

  // 3. 确保有当前记录
  if (!currentRecord.value) {
    currentRecord.value = createEmptyDailyRecord()
  }

  // 4. 确保 journalEntries 数组存在
  if (!currentRecord.value.journalEntries) {
    currentRecord.value.journalEntries = []
  }

  // 5. 调用服务层添加条目
  const result = addJournalEntryService(
    currentRecord.value.journalEntries,
    content,
    mood
  )

  if (!result) {
    return null
  }

  // 6. 更新状态
  currentRecord.value.journalEntries = result.entries
  markModified()

  return result.newEntry.id
}
```

**富文本编辑器实现：**

```typescript
// src/composables/useRichTextEditor.ts
import { useEditor } from '@tiptap/vue-3'
import StarterKit from '@tiptap/starter-kit'
import Placeholder from '@tiptap/extension-placeholder'

export function useRichTextEditor(
  content: string,
  onUpdate: (html: string) => void
) {
  const editor = useEditor({
    content,
    extensions: [
      StarterKit.configure({
        heading: {
          levels: [1, 2, 3]
        }
      }),
      Placeholder.configure({
        placeholder: '记录今天的点滴...'
      })
    ],
    onUpdate: ({ editor }) => {
      onUpdate(editor.getHTML())
    }
  })

  return { editor }
}
```

**富文本编辑器组件：**

```vue
<!-- src/components/journal/RichTextEditor.vue -->
<template>
  <div class="rich-text-editor">
    <EditorToolbar v-if="editor" :editor="editor" />
    <EditorContent :editor="editor" />
  </div>
</template>

<script setup lang="ts">
import { EditorContent } from '@tiptap/vue-3'
import { useRichTextEditor } from '@/composables/useRichTextEditor'

const props = defineProps<{
  modelValue: string
}>()

const emit = defineEmits<{
  'update:modelValue': [value: string]
}>()

const { editor } = useRichTextEditor(props.modelValue, (html) => {
  emit('update:modelValue', html)
})
</script>
```

---

### 3.3 封存机制

**核心逻辑：**

```typescript
/**
 * 判断是否可以封存
 * 位置：src/stores/daily.ts:131-152
 */
const canSeal = computed(() => {
  if (!currentRecord.value || currentRecord.value.isSealed) {
    return false
  }

  const hasTasks = currentRecord.value.tasks.length > 0
  const allTasksCompleted = hasTasks && currentRecord.value.tasks.every(t => t.completed)
  const journalMeetsMinLength = currentRecord.value.journal.length >= MIN_JOURNAL_LENGTH
  const hasJournalContent = currentRecord.value.journal.trim().length > 0
  const hasMood = currentRecord.value.mood !== null
  const hasJournalEntries = (currentRecord.value.journalEntries?.length ?? 0) > 0

  // 封存条件：
  // 1. 有任务时：所有任务已完成 OR 日记达到最低字数 OR 有日记条目
  // 2. 无任务时：有日记内容（不限字数）OR 选择了心情 OR 有日记条目
  if (hasTasks) {
    return allTasksCompleted || journalMeetsMinLength || hasJournalEntries
  } else {
    return hasJournalContent || hasMood || hasJournalEntries
  }
})
```

**封存操作：**

```typescript
/**
 * 封存今日记录
 * 位置：src/stores/daily.ts:492-525
 */
function sealDay(): boolean {
  if (!currentRecord.value || currentRecord.value.isSealed) {
    return false
  }

  // 验证封存条件
  if (!canSeal.value) {
    return false
  }

  // 标记为已封存
  currentRecord.value.isSealed = true
  currentRecord.value.sealedAt = new Date().toISOString()

  // 更新完成率
  updateCompletionRate()

  // 触发保存
  markModified()

  return true
}
```

**解封操作：**

```typescript
// src/services/seal.ts

/**
 * 解封记录
 */
export function unsealRecord(record: DailyRecord): DailyRecord | null {
  if (!record.isSealed) {
    return null
  }

  return {
    ...record,
    isSealed: false,
    sealedAt: null
  }
}
```

---

### 3.4 番茄钟模块

**状态管理：**

```typescript
// src/stores/pomodoro.ts
export const usePomodoroStore = defineStore('pomodoro', () => {
  // State
  const timerState = ref<TimerState>('idle')  // idle | focusing | break | paused
  const timeLeft = ref(0)  // 剩余秒数
  const selectedTaskId = ref<string | null>(null)
  const settings = ref<PomodoroSettings>(DEFAULT_POMODORO_SETTINGS)

  // Getters
  const minutes = computed(() => Math.floor(timeLeft.value / 60))
  const seconds = computed(() => timeLeft.value % 60)

  // Actions
  function startFocus(taskId?: string) {
    selectedTaskId.value = taskId || null
    timeLeft.value = settings.value.focusDuration * 60
    timerState.value = 'focusing'
    startTimer()
  }

  function pause() {
    timerState.value = 'paused'
    stopTimer()
  }

  function resume() {
    timerState.value = 'focusing'
    startTimer()
  }

  return { timerState, timeLeft, minutes, seconds, startFocus, pause, resume }
})
```

**计时器实现：**

```typescript
// 计时器 interval ID
let timerInterval: number | null = null

function startTimer() {
  if (timerInterval) {
    clearInterval(timerInterval)
  }

  timerInterval = setInterval(() => {
    if (timeLeft.value > 0) {
      timeLeft.value--
    } else {
      // 时间到
      handleTimerComplete()
    }
  }, 1000)
}

function stopTimer() {
  if (timerInterval) {
    clearInterval(timerInterval)
    timerInterval = null
  }
}

async function handleTimerComplete() {
  stopTimer()

  if (timerState.value === 'focusing') {
    // 专注完成，保存记录
    await saveFocusRecord()
    // 进入休息模式
    startBreak()
  } else if (timerState.value === 'break') {
    // 休息完成，回到空闲状态
    timerState.value = 'idle'
  }
}
```

**专注记录保存：**

```typescript
// src/services/pomodoro.ts

/**
 * 保存专注记录到数据库
 */
export async function saveFocusRecord(
  taskId: string | null,
  taskDescription: string | null,
  duration: number
): Promise<boolean> {
  const record: FocusRecord = {
    id: generateUUID(),
    taskId,
    taskDescription,
    duration,
    completedAt: new Date().toISOString(),
    date: getTodayDateString()
  }

  // 保存到数据库
  const { error } = await supabase
    .from('focus_records')
    .insert({
      ...record,
      user_id: (await supabase.auth.getUser()).data.user?.id
    })

  return !error
}
```

---

## 四、数据库设计

### 4.1 ER 图

```
┌─────────────────┐
│   auth.users    │ (Supabase 内置表)
│─────────────────│
│ id (PK)         │
│ email           │
│ created_at      │
└────────┬────────┘
         │ 1
         │
         │ N
┌────────┴────────┐       ┌─────────────────┐
│ user_profiles   │       │  focus_records  │
│─────────────────│       │─────────────────│
│ id (PK, FK)     │       │ id (PK)         │
│ nickname        │       │ user_id (FK)    │
│ avatar_url      │       │ task_id         │
│ created_at      │       │ duration        │
│ updated_at      │       │ completed_at    │
└─────────────────┘       │ date            │
                          └─────────────────┘

┌─────────────────┐
│ daily_records   │
│─────────────────│
│ id (PK)         │◄──────┐
│ user_id (FK)    │       │ N
│ date            │       │
│ journal         │       │
│ mood            │       │
│ is_sealed       │  ┌────┴──────────┐  ┌─────────────────┐
│ completion_rate │  │     tasks     │  │journal_entries  │
│ created_at      │  │───────────────│  │─────────────────│
│ sealed_at       │  │ id (PK)       │  │ id (PK)         │
└─────────────────┘  │ record_id(FK) │  │ record_id (FK)  │
                     │ user_id (FK)  │  │ user_id (FK)    │
                     │ description   │  │ content         │
                     │ completed     │  │ mood            │
                     │ priority      │  │ created_at      │
                     │ tags          │  └─────────────────┘
                     │ sort_order    │
                     │ created_at    │
                     │ completed_at  │
                     └───────────────┘
```

### 4.2 表结构详解

#### 4.2.1 daily_records 表

```sql
CREATE TABLE daily_records (
  id UUID PRIMARY KEY,                  -- 日期字符串 (YYYY-MM-DD)
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  date DATE NOT NULL,                   -- 日期
  journal TEXT DEFAULT '',              -- 旧字段：日记内容
  mood TEXT,                            -- 旧字段：心情
  is_sealed BOOLEAN DEFAULT FALSE,      -- 是否封存
  completion_rate INTEGER DEFAULT 0,    -- 完成率 (0-100)
  created_at TIMESTAMPTZ DEFAULT NOW(), -- 创建时间
  sealed_at TIMESTAMPTZ                 -- 封存时间
);

-- 索引
CREATE INDEX idx_daily_records_user_date ON daily_records(user_id, date);
CREATE INDEX idx_daily_records_sealed ON daily_records(user_id, is_sealed);
```

**设计说明：**
- `id` 使用日期字符串（YYYY-MM-DD），方便查询
- `user_id` 外键关联用户，支持用户数据隔离
- 保留 `journal` 和 `mood` 字段是为了向后兼容
- `is_sealed` 标记是否封存，影响是否可编辑
- `completion_rate` 冗余存储完成率，避免每次计算

#### 4.2.2 tasks 表

```sql
CREATE TABLE tasks (
  id UUID PRIMARY KEY,
  record_id UUID NOT NULL REFERENCES daily_records(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  description TEXT NOT NULL,            -- 任务描述
  completed BOOLEAN DEFAULT FALSE,      -- 完成状态
  priority TEXT DEFAULT 'medium',       -- 优先级 (high/medium/low)
  tags TEXT[] DEFAULT '{}',             -- 标签数组
  sort_order INTEGER DEFAULT 0,         -- 排序顺序
  created_at TIMESTAMPTZ DEFAULT NOW(), -- 创建时间
  completed_at TIMESTAMPTZ              -- 完成时间
);

-- 索引
CREATE INDEX idx_tasks_record ON tasks(record_id, sort_order);
CREATE INDEX idx_tasks_user ON tasks(user_id);
```

**设计说明：**
- `record_id` 外键关联每日记录
- `tags` 使用 PostgreSQL 的数组类型，支持多标签
- `sort_order` 用于拖拽排序
- `completed_at` 记录完成时间，用于统计

#### 4.2.3 journal_entries 表

```sql
CREATE TABLE journal_entries (
  id UUID PRIMARY KEY,
  record_id UUID NOT NULL REFERENCES daily_records(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,                -- 日记内容 (HTML)
  mood TEXT,                            -- 心情 (可选)
  created_at TIMESTAMPTZ DEFAULT NOW()  -- 创建时间
);

-- 索引
CREATE INDEX idx_journal_entries_record ON journal_entries(record_id, created_at DESC);
CREATE INDEX idx_journal_entries_user ON journal_entries(user_id);
```

**设计说明：**
- 独立表存储日记条目，支持多条目
- `content` 存储 HTML 格式的富文本
- `mood` 可选，每条日记可以有不同心情
- 按 `created_at` 降序索引，方便按时间倒序查询

#### 4.2.4 user_profiles 表

```sql
CREATE TABLE user_profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  nickname TEXT,                        -- 昵称 (1-20字符)
  avatar_url TEXT,                      -- 头像 URL
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

#### 4.2.5 focus_records 表

```sql
CREATE TABLE focus_records (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  task_id UUID,                         -- 关联任务 ID (可空)
  task_description TEXT,                -- 任务描述快照 (可空)
  duration INTEGER NOT NULL,            -- 专注时长（分钟）
  completed_at TIMESTAMPTZ DEFAULT NOW(), -- 完成时间
  date DATE NOT NULL                    -- 日期
);

-- 索引
CREATE INDEX idx_focus_records_user_date ON focus_records(user_id, date);
```

---

### 4.3 Row Level Security (RLS) 策略

**为什么需要 RLS：**
- 在数据库层面保护数据，即使 API 密钥泄露也无法访问其他用户数据
- 自动应用于所有查询，无需在应用层重复检查
- PostgreSQL 原生支持，性能好

**RLS 策略示例：**

```sql
-- 启用 RLS
ALTER TABLE daily_records ENABLE ROW LEVEL SECURITY;

-- 用户只能查看自己的记录
CREATE POLICY "用户只能查看自己的记录"
  ON daily_records FOR SELECT
  USING (auth.uid() = user_id);

-- 用户只能创建自己的记录
CREATE POLICY "用户只能创建自己的记录"
  ON daily_records FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- 用户只能更新自己的记录
CREATE POLICY "用户只能更新自己的记录"
  ON daily_records FOR UPDATE
  USING (auth.uid() = user_id);

-- 用户只能删除自己的记录
CREATE POLICY "用户只能删除自己的记录"
  ON daily_records FOR DELETE
  USING (auth.uid() = user_id);
```

**应用层代码：**

```typescript
// src/services/database.ts

async function getCurrentUserId(): Promise<string | null> {
  const { data: { user } } = await supabase.auth.getUser()
  return user?.id || null
}

async loadDailyRecord(date: string) {
  const userId = await getCurrentUserId()
  if (!userId) {
    return { success: false, error: '请先登录' }
  }

  // 查询时不需要手动过滤 user_id，RLS 会自动过滤
  const { data, error } = await supabase
    .from('daily_records')
    .select('*')
    .eq('id', date)
    .single()

  return { success: !error, data }
}
```

---

## 五、状态管理

### 5.1 Pinia Store 架构

**6个 Store 的职责划分：**

| Store | 职责 | 文件路径 |
|-------|------|---------|
| **auth** | 用户认证、会话管理 | `src/stores/auth.ts` |
| **daily** | 今日数据（任务、日记） | `src/stores/daily.ts` |
| **archive** | 归档数据、搜索 | `src/stores/archive.ts` |
| **profile** | 用户资料、头像 | `src/stores/profile.ts` |
| **pomodoro** | 番茄钟状态、设置 | `src/stores/pomodoro.ts` |
| **settings** | 应用设置（主题等） | `src/stores/settings.ts` |

### 5.2 daily Store 详解

**完整结构：**

```typescript
export const useDailyStore = defineStore('daily', () => {
  // ========== State ==========
  const currentRecord = ref<DailyRecord | null>(null)
  const isDataLoading = ref(false)
  const lastLocalChangeAt = ref<number>(Date.now())

  // ========== Getters ==========
  const isSealed = computed(() => currentRecord.value?.isSealed ?? false)
  const taskCount = computed(() => currentRecord.value?.tasks.length ?? 0)
  const completedCount = computed(() =>
    currentRecord.value?.tasks.filter(t => t.completed).length ?? 0
  )
  const completionRate = computed(() => {
    if (!currentRecord.value || currentRecord.value.tasks.length === 0) {
      return 0
    }
    const total = currentRecord.value.tasks.length
    const completed = currentRecord.value.tasks.filter(t => t.completed).length
    return Math.round((completed / total) * 100)
  })
  const canSeal = computed(() => {
    // 复杂的封存条件判断逻辑...
  })
  const overallMood = computed(() => {
    // 获取整体心情...
  })
  const sortedJournalEntries = computed(() => {
    // 返回排序后的日记条目...
  })

  // ========== Actions ==========

  // 任务管理
  function addTask(description: string, priority: Priority, tags: string[]): string | null { }
  function removeTask(id: string): boolean { }
  function toggleTask(id: string): boolean { }
  function updateTaskOrder(tasks: Task[]): boolean { }
  function batchUpdateTasks(updates: Array<{ id: string; completed?: boolean }>): number { }

  // 日记管理
  function updateJournal(content: string): boolean { }
  function updateMood(mood: MoodType): boolean { }
  function addJournalEntry(content: string, mood: MoodType | null): string | null { }
  function editJournalEntry(id: string, content: string): boolean { }
  function deleteJournalEntry(id: string): boolean { }

  // 封存与解封
  function sealDay(): boolean { }
  function unsealDay(): boolean { }
  function loadAndUnsealRecord(record: DailyRecord): boolean { }

  // 数据加载
  function loadToday(): void { }
  async function loadTodayAsync(): Promise<void> { }

  // 辅助函数
  function updateCompletionRate(): void { }
  function markModified(): void { }
  function $reset(): void { }

  return {
    // State
    currentRecord,
    isSealed,
    isDataLoading,
    // Getters
    taskCount,
    completedCount,
    completionRate,
    canSeal,
    overallMood,
    sortedJournalEntries,
    // Actions
    addTask,
    removeTask,
    toggleTask,
    updateTaskOrder,
    batchUpdateTasks,
    updateJournal,
    updateMood,
    sealDay,
    loadToday,
    loadTodayAsync,
    addJournalEntry,
    editJournalEntry,
    deleteJournalEntry,
    unsealDay,
    loadAndUnsealRecord,
    $reset
  }
})
```

### 5.3 数据持久化机制

**自动保存流程：**

```typescript
// src/services/storage.ts

/**
 * StorageService - 负责数据持久化
 */
export const StorageService = {
  /**
   * 自动保存：监听 daily store 变化
   */
  setupAutoSave() {
    const dailyStore = useDailyStore()

    // 监听 currentRecord 变化
    watch(
      () => dailyStore.currentRecord,
      debounce(async (newRecord) => {
        if (!newRecord || dailyStore.isDataLoading) {
          return
        }

        // 保存到数据库
        await DatabaseService.saveDailyRecord(newRecord)
      }, 1000),  // 防抖 1 秒
      { deep: true }
    )
  }
}
```

**初始化流程：**

```typescript
// src/main.ts

import { StorageService } from '@/services/storage'

const app = createApp(App)
app.use(pinia)
app.use(router)

// 设置自动保存
StorageService.setupAutoSave()

app.mount('#app')
```

---

## 六、关键算法

### 6.1 UUID 生成

```typescript
/**
 * 生成 UUID v4 格式的唯一标识符
 * 位置：src/stores/daily.ts:31-37
 */
function generateUUID(): string {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0
    const v = c === 'x' ? r : (r & 0x3) | 0x8
    return v.toString(16)
  })
}
```

**说明：**
- 符合 UUID v4 标准
- 使用位运算提高性能
- 碰撞概率极低（2^122）

### 6.2 连续打卡天数计算

```typescript
/**
 * 计算连续打卡天数
 * 位置：src/services/stats.ts
 */
export function calculateConsecutiveDays(records: DailyRecord[]): number {
  if (records.length === 0) return 0

  // 按日期降序排序
  const sortedRecords = records
    .filter(r => r.isSealed)
    .sort((a, b) => b.date.localeCompare(a.date))

  let consecutiveDays = 0
  let expectedDate = getTodayDateString()

  for (const record of sortedRecords) {
    if (record.date === expectedDate) {
      consecutiveDays++
      // 计算前一天的日期
      expectedDate = subtractDays(expectedDate, 1)
    } else {
      // 中断
      break
    }
  }

  return consecutiveDays
}

/**
 * 日期减法
 */
function subtractDays(dateStr: string, days: number): string {
  const date = new Date(dateStr)
  date.setDate(date.getDate() - days)
  return date.toISOString().split('T')[0]
}
```

### 6.3 完成率趋势计算

```typescript
/**
 * 计算最近 N 天的完成率趋势
 */
export function calculateCompletionTrend(
  records: DailyRecord[],
  days: number = 7
): TrendPoint[] {
  const today = new Date()
  const points: TrendPoint[] = []

  for (let i = days - 1; i >= 0; i--) {
    const date = new Date(today)
    date.setDate(date.getDate() - i)
    const dateStr = date.toISOString().split('T')[0]

    const record = records.find(r => r.date === dateStr)
    const rate = record ? record.completionRate : 0

    points.push({ date: dateStr, rate })
  }

  return points
}
```

### 6.4 心情分布统计

```typescript
/**
 * 统计各种心情出现的次数
 */
export function calculateMoodDistribution(records: DailyRecord[]): MoodCount[] {
  const moodMap = new Map<MoodType, number>()

  for (const record of records) {
    // 检查日记条目中的心情
    for (const entry of record.journalEntries || []) {
      if (entry.mood) {
        moodMap.set(entry.mood, (moodMap.get(entry.mood) || 0) + 1)
      }
    }

    // 兼容旧数据
    if (record.mood && !record.journalEntries?.length) {
      moodMap.set(record.mood, (moodMap.get(record.mood) || 0) + 1)
    }
  }

  return Array.from(moodMap.entries()).map(([mood, count]) => ({
    mood,
    count
  }))
}
```

---

## 七、性能优化

### 7.1 虚拟滚动

**为什么需要虚拟滚动：**
- 归档列表可能有数百条记录
- 一次性渲染所有记录会导致页面卡顿
- 虚拟滚动只渲染可见区域的条目

**实现原理：**

```typescript
// src/composables/useVirtualScroll.ts

export function useVirtualScroll<T>(
  items: Ref<T[]>,
  itemHeight: number
) {
  const containerRef = ref<HTMLElement | null>(null)
  const scrollTop = ref(0)
  const containerHeight = ref(0)

  // 可见区域的起始和结束索引
  const startIndex = computed(() => {
    return Math.floor(scrollTop.value / itemHeight)
  })

  const endIndex = computed(() => {
    return Math.ceil((scrollTop.value + containerHeight.value) / itemHeight)
  })

  // 可见的条目
  const visibleItems = computed(() => {
    return items.value.slice(startIndex.value, endIndex.value + 1)
  })

  // 总高度
  const totalHeight = computed(() => {
    return items.value.length * itemHeight
  })

  // 偏移量
  const offsetY = computed(() => {
    return startIndex.value * itemHeight
  })

  // 监听滚动
  function handleScroll(event: Event) {
    const target = event.target as HTMLElement
    scrollTop.value = target.scrollTop
  }

  return {
    containerRef,
    visibleItems,
    totalHeight,
    offsetY,
    handleScroll
  }
}
```

**使用示例：**

```vue
<template>
  <div
    ref="containerRef"
    @scroll="handleScroll"
    class="virtual-scroll-container"
  >
    <div :style="{ height: totalHeight + 'px' }">
      <div :style="{ transform: `translateY(${offsetY}px)` }">
        <ArchiveCard
          v-for="record in visibleItems"
          :key="record.id"
          :record="record"
        />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { useVirtualScroll } from '@/composables/useVirtualScroll'

const records = ref<DailyRecord[]>([...])  // 数百条记录

const {
  containerRef,
  visibleItems,
  totalHeight,
  offsetY,
  handleScroll
} = useVirtualScroll(records, 120)  // 每条高度 120px
</script>
```

### 7.2 批量任务更新

**问题：**
- 用户可能一次性完成多个任务
- 每次更新都触发数据库保存，性能差

**解决方案：批量更新**

```typescript
/**
 * 批量更新任务
 * 位置：src/stores/daily.ts:579-602
 */
function batchUpdateTasks(updates: Array<{ id: string; completed?: boolean }>): number {
  if (!currentRecord.value || currentRecord.value.isSealed) {
    return 0
  }

  let updatedCount = 0
  const now = new Date().toISOString()

  // 一次性更新所有任务
  for (const update of updates) {
    const task = currentRecord.value.tasks.find(t => t.id === update.id)
    if (task && update.completed !== undefined) {
      task.completed = update.completed
      task.completedAt = update.completed ? now : null
      updatedCount++
    }
  }

  if (updatedCount > 0) {
    // 只触发一次响应式更新
    updateCompletionRate()
    markModified()
  }

  return updatedCount
}
```

### 7.3 防抖（Debounce）

**问题：**
- 用户输入日记时，每次按键都触发保存
- 频繁保存浪费资源

**解决方案：防抖**

```typescript
// src/services/storage.ts

import { debounce } from 'lodash-es'  // 或自己实现

export const StorageService = {
  setupAutoSave() {
    const dailyStore = useDailyStore()

    watch(
      () => dailyStore.currentRecord,
      debounce(async (newRecord) => {
        if (!newRecord || dailyStore.isDataLoading) {
          return
        }
        await DatabaseService.saveDailyRecord(newRecord)
      }, 1000),  // 1秒内多次变更只保存一次
      { deep: true }
    )
  }
}
```

**自己实现 debounce：**

```typescript
function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: number | null = null

  return function(...args: Parameters<T>) {
    if (timeout) {
      clearTimeout(timeout)
    }

    timeout = setTimeout(() => {
      func(...args)
    }, wait)
  }
}
```

### 7.4 路由懒加载

**问题：**
- 一次性加载所有页面组件，首屏加载慢

**解决方案：按需加载**

```typescript
// src/router/index.ts

const routes = [
  {
    path: '/dashboard',
    name: 'Dashboard',
    // 懒加载：只有访问时才加载组件
    component: () => import('@/views/DashboardView.vue')
  },
  {
    path: '/stats',
    name: 'Stats',
    component: () => import('@/views/StatsView.vue')
  },
  // ...
]
```

**Vite 会自动进行代码分割：**

```
dist/
├── assets/
│   ├── DashboardView-xxx.js
│   ├── StatsView-yyy.js
│   └── ...
```

---

## 八、安全机制

### 8.1 认证流程

**Magic Link 登录流程：**

```
1. 用户输入邮箱
   ↓
2. 调用 Supabase Auth API
   ↓
3. Supabase 发送登录链接到邮箱
   ↓
4. 用户点击邮件链接
   ↓
5. 重定向到应用，携带 token
   ↓
6. 应用验证 token，创建会话
   ↓
7. 存储会话到 localStorage
```

**代码实现：**

```typescript
// src/services/auth.ts

/**
 * 发送 Magic Link
 */
export async function sendMagicLink(email: string): Promise<AuthResult> {
  try {
    const { error } = await supabase.auth.signInWithOtp({
      email,
      options: {
        emailRedirectTo: window.location.origin + '/dashboard'
      }
    })

    if (error) {
      return { success: false, error: { code: 'AUTH_ERROR', message: error.message } }
    }

    return { success: true }
  } catch (error) {
    return { success: false, error: { code: 'NETWORK_ERROR', message: '网络错误' } }
  }
}

/**
 * 获取当前会话
 */
export async function getSession(): Promise<Session | null> {
  const { data: { session } } = await supabase.auth.getSession()

  if (!session) {
    return null
  }

  return {
    accessToken: session.access_token,
    refreshToken: session.refresh_token,
    expiresAt: session.expires_at || 0,
    user: {
      id: session.user.id,
      email: session.user.email || '',
      createdAt: session.user.created_at,
      lastSignInAt: session.user.last_sign_in_at || ''
    }
  }
}

/**
 * 退出登录
 */
export async function signOut(): Promise<void> {
  await supabase.auth.signOut()
}
```

### 8.2 路由守卫

```typescript
// src/router/index.ts

router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore()

  // 检查是否已初始化
  if (!authStore.initialized) {
    await authStore.initializeAuth()
  }

  const isAuthenticated = authStore.isAuthenticated
  const requiresAuth = to.meta.requiresAuth

  if (requiresAuth && !isAuthenticated) {
    // 需要认证但未登录，重定向到登录页
    next({ name: 'Login', query: { redirect: to.fullPath } })
  } else if (to.name === 'Login' && isAuthenticated) {
    // 已登录用户访问登录页，重定向到仪表盘
    next({ name: 'Dashboard' })
  } else {
    next()
  }
})
```

### 8.3 XSS 防护

**问题：**
- 用户输入的日记内容可能包含恶意脚本

**解决方案：**

1. **使用 Tiptap 编辑器**：自动过滤危险标签
2. **CSP (Content Security Policy)**：限制脚本来源

```html
<!-- index.html -->
<meta
  http-equiv="Content-Security-Policy"
  content="default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline';"
>
```

3. **渲染时转义**：Vue 自动转义文本内容

```vue
<!-- ✅ 安全：Vue 自动转义 -->
<div>{{ userInput }}</div>

<!-- ❌ 危险：使用 v-html 需要确保内容安全 -->
<div v-html="sanitizedHtml"></div>
```

### 8.4 头像上传安全

```typescript
// src/services/avatar.ts

/**
 * 验证头像文件
 */
export function validateAvatar(file: File): AvatarValidationResult {
  // 1. 检查文件类型
  const validTypes = ['image/jpeg', 'image/png']
  if (!validTypes.includes(file.type)) {
    return { valid: false, error: '请选择 JPG 或 PNG 格式的图片' }
  }

  // 2. 检查文件大小 (5MB)
  const maxSize = 5 * 1024 * 1024
  if (file.size > maxSize) {
    return { valid: false, error: '图片大小不能超过 5MB' }
  }

  return { valid: true }
}

/**
 * 上传头像
 */
export async function uploadAvatar(file: File, userId: string): Promise<AvatarResult> {
  // 1. 验证文件
  const validation = validateAvatar(file)
  if (!validation.valid) {
    return { success: false, error: { code: 'INVALID_FILE', message: validation.error! } }
  }

  // 2. 生成唯一文件名
  const fileExt = file.name.split('.').pop()
  const fileName = `${userId}-${Date.now()}.${fileExt}`

  // 3. 上传到 Supabase Storage
  const { error } = await supabase.storage
    .from('avatars')
    .upload(`${userId}/${fileName}`, file)

  if (error) {
    return { success: false, error: { code: 'UPLOAD_ERROR', message: '上传失败' } }
  }

  // 4. 获取公开 URL
  const { data } = supabase.storage
    .from('avatars')
    .getPublicUrl(`${userId}/${fileName}`)

  return { success: true, url: data.publicUrl }
}
```

---

## 九、测试策略

### 9.1 测试工具

- **Vitest**：快速的单元测试框架，与 Vite 集成良好
- **@vue/test-utils**：Vue 组件测试工具
- **jsdom**：模拟浏览器环境

### 9.2 测试示例

**Store 单元测试：**

```typescript
// src/stores/__tests__/daily.test.ts
import { describe, it, expect, beforeEach } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useDailyStore } from '../daily'

describe('Daily Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })

  it('添加任务', () => {
    const store = useDailyStore()
    const taskId = store.addTask('测试任务', 'high', ['测试'])

    expect(taskId).toBeTruthy()
    expect(store.taskCount).toBe(1)
    expect(store.currentRecord?.tasks[0].description).toBe('测试任务')
  })

  it('拒绝空任务', () => {
    const store = useDailyStore()
    const taskId = store.addTask('')

    expect(taskId).toBeNull()
    expect(store.taskCount).toBe(0)
  })

  it('计算完成率', () => {
    const store = useDailyStore()
    store.addTask('任务1')
    store.addTask('任务2')
    store.addTask('任务3')

    expect(store.completionRate).toBe(0)

    // 完成第一个任务
    const task1Id = store.currentRecord!.tasks[0].id
    store.toggleTask(task1Id)

    expect(store.completionRate).toBe(33)  // 1/3 ≈ 33%
  })
})
```

**组件测试：**

```typescript
// src/components/task/__tests__/TaskItem.test.ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import TaskItem from '../TaskItem.vue'

describe('TaskItem', () => {
  it('渲染任务', () => {
    const task = {
      id: '1',
      description: '测试任务',
      completed: false,
      priority: 'high',
      tags: ['测试'],
      order: 0,
      createdAt: '2024-01-01T00:00:00Z',
      completedAt: null
    }

    const wrapper = mount(TaskItem, {
      props: { task }
    })

    expect(wrapper.text()).toContain('测试任务')
    expect(wrapper.find('.priority-high').exists()).toBe(true)
  })

  it('点击复选框触发事件', async () => {
    const wrapper = mount(TaskItem, {
      props: { task: { /* ... */ } }
    })

    await wrapper.find('input[type="checkbox"]').setValue(true)

    expect(wrapper.emitted('toggle')).toBeTruthy()
  })
})
```

---

## 十、常见技术问题解答

### Q1：为什么选择 Vue 3 而不是 React？

**答：**

1. **学习曲线**：Vue 的模板语法更接近 HTML，学习成本低
2. **Composition API**：提供类似 React Hooks 的能力，同时保留了 Options API
3. **响应式系统**：基于 Proxy 的响应式，写法直观，性能好
4. **单文件组件**：HTML、CSS、JS 在同一个文件，开发体验好
5. **生态成熟**：Vue Router、Pinia、Vite 官方支持，配套完善

对于中小型项目，Vue 的开发效率更高。

### Q2：Pinia 相比 Vuex 有什么优势？

**答：**

| 特性 | Vuex | Pinia |
|-----|------|-------|
| Mutations | 必须 | 不需要，直接修改 state |
| TypeScript | 类型推导困难 | 完全类型安全 |
| API 风格 | Options API | Composition API |
| 模块化 | 嵌套模块 | 扁平化 Store |
| DevTools | 支持 | 更好的支持 |
| 包大小 | ~4KB | ~1KB |

**示例对比：**

```typescript
// Vuex
store.commit('increment')

// Pinia
store.increment()
```

Pinia 更简洁、类型更安全、性能更好。

### Q3：为什么使用 Supabase 而不是自己搭建后端？

**答：**

**优势：**
1. **快速开发**：无需编写后端代码，专注于前端业务逻辑
2. **功能完整**：数据库、认证、存储、实时订阅开箱即用
3. **PostgreSQL**：成熟的关系型数据库，支持复杂查询
4. **RLS 安全**：数据库层面的安全策略
5. **开源**：可以自托管，不担心厂商锁定
6. **免费额度**：个人项目免费使用

**适用场景：**
- 中小型项目
- MVP 快速验证
- 学习和原型开发

**不适合：**
- 需要复杂后端逻辑的大型项目
- 对响应时间要求极高的应用

### Q4：如何保证数据安全？

**答：**

**多层安全机制：**

1. **认证层**：
   - Magic Link 无密码登录
   - JWT token 验证
   - 会话自动刷新

2. **数据库层**：
   - Row Level Security (RLS)
   - 用户数据自动隔离
   - 外键约束保证数据完整性

3. **应用层**：
   - 输入验证（任务描述、日记内容）
   - 文件上传验证（类型、大小）
   - XSS 防护（Tiptap 过滤、Vue 转义）

4. **传输层**：
   - HTTPS 加密传输
   - Supabase API 使用 TLS

### Q5：封存功能的业务逻辑是什么？

**答：**

**封存条件判断（src/stores/daily.ts:131-152）：**

```typescript
if (hasTasks) {
  // 有任务时：三个条件满足其一即可封存
  return allTasksCompleted || journalMeetsMinLength || hasJournalEntries
} else {
  // 无任务时：三个条件满足其一即可封存
  return hasJournalContent || hasMood || hasJournalEntries
}
```

**设计思路：**
- **灵活性**：不强制要求完成所有任务，鼓励记录
- **最低要求**：至少有一些内容（任务完成/日记/心情）
- **日记优先**：日记达到 50 字可直接封存，鼓励写日记

**封存后：**
- 所有内容变为只读
- 记录封存时间戳
- 可以选择解封（用于修正错误）

### Q6：多条目日记是如何实现的？

**答：**

**数据结构设计：**

```typescript
// 旧版：一天一条日记
interface DailyRecord {
  journal: string  // 单个字符串
  mood: MoodType | null
}

// 新版：一天多条日记
interface DailyRecord {
  journal: string               // 保留，兼容旧数据
  mood: MoodType | null         // 保留，兼容旧数据
  journalEntries: JournalEntry[] // 新增
}

interface JournalEntry {
  id: string
  content: string
  mood: MoodType | null
  createdAt: string
}
```

**数据迁移（src/stores/daily.ts:69-91）：**

```typescript
function migrateJournalData(record: DailyRecord): DailyRecord {
  if (!record.journalEntries) {
    record.journalEntries = []
  }

  // 如果有旧的 journal 内容且 journalEntries 为空，则迁移
  if (record.journal && record.journal.trim().length > 0 && record.journalEntries.length === 0) {
    record.journalEntries = [{
      id: generateUUID(),
      content: record.journal,
      mood: record.mood,
      createdAt: record.createdAt
    }]
  }

  return record
}
```

**好处：**
- 向后兼容：旧数据自动升级
- 更符合实际：一天可能多次记录
- 独立时间戳：每条日记有自己的时间
- 独立心情：每条日记可以有不同心情

### Q7：性能优化做了哪些工作？

**答：**

1. **虚拟滚动**（src/composables/useVirtualScroll.ts）：
   - 归档列表只渲染可见区域
   - 减少 DOM 节点数量
   - 提升长列表性能

2. **批量更新**（src/stores/daily.ts:579-602）：
   - 一次性更新多个任务
   - 减少响应式触发次数
   - 减少数据库操作

3. **防抖**（src/services/storage.ts）：
   - 自动保存使用防抖
   - 1秒内多次变更只保存一次
   - 减少网络请求

4. **路由懒加载**（src/router/index.ts）：
   - 按需加载页面组件
   - 减小首屏包大小
   - 加快首次加载

5. **代码分割**（vite.config.ts）：
   - 第三方库单独打包
   - ECharts 单独打包
   - 利用浏览器缓存

### Q8：如果要扩展功能，应该如何设计？

**答：**

**示例：添加"任务提醒"功能**

1. **定义类型**（src/types/index.ts）：
```typescript
export interface TaskReminder {
  id: string
  taskId: string
  remindAt: string  // ISO 8601
  message: string
}
```

2. **创建服务**（src/services/reminder.ts）：
```typescript
export const ReminderService = {
  async createReminder(reminder: TaskReminder) { },
  async deleteReminder(id: string) { },
  async getUpcomingReminders() { }
}
```

3. **扩展 Store**（src/stores/daily.ts）：
```typescript
const reminders = ref<TaskReminder[]>([])

function addReminder(taskId: string, remindAt: string) {
  // ...
}
```

4. **创建组件**（src/components/task/ReminderSettings.vue）：
```vue
<template>
  <div class="reminder-settings">
    <!-- 提醒设置 UI -->
  </div>
</template>
```

5. **数据库迁移**（supabase/migrations/xxx_create_reminders.sql）：
```sql
CREATE TABLE reminders (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id),
  task_id UUID REFERENCES tasks(id),
  remind_at TIMESTAMPTZ,
  message TEXT
);
```

**设计原则：**
- 模块化：新功能独立模块
- 分层清晰：Service → Store → Component
- 向后兼容：不破坏现有功能
- 测试覆盖：编写单元测试

---

## 总结

本项目展示了现代化 Web 应用的完整开发流程：

✅ **技术栈**：Vue 3 + TypeScript + Vite + Supabase
✅ **架构设计**：清晰的分层架构，职责明确
✅ **数据库设计**：合理的表结构，RLS 安全策略
✅ **状态管理**：Pinia 管理复杂状态
✅ **性能优化**：虚拟滚动、批量更新、防抖
✅ **安全机制**：认证、路由守卫、XSS 防护
✅ **测试覆盖**：单元测试保证代码质量

**代码质量特点：**
- 类型安全（TypeScript）
- 注释详尽（文档化代码）
- 模块化（易于维护）
- 可测试（单元测试覆盖）

**适合学习的知识点：**
- Vue 3 Composition API
- Pinia 状态管理
- Supabase BaaS 使用
- TypeScript 类型设计
- 性能优化技巧
- 数据库设计
- 安全防护

---

**文档版本**：v1.0
**最后更新**：2025-12-11
